# [Коллекции](https://github.com/Tirensky/JavaLearning/tree/master/Collections/src)
В стандартной библиотеке Java содержиться множество различных коллекции. И для понимания, чем каждая отличается друг от друга и как они устроены изнутри, я воссоздал некоторые коллекции в простом виде.
Для их изучения был выбран разбор тематической задачи "Система учёта автомобилей".

>  *Проект был создан с использованием системы сборки gradle и библиотеки JUnit5*

### Задача
Написать систему учёта автомобилей. Согласно требованию, нужен класс, который будет описывать авто и класс, который будет хранить в себе объекты этого (и любого другого) типа - то есть систему.

**На первое время система должна реализовывать:**
- получение информации об автомобиле по индексу и их количество
- добавление нового автомобиля в список
- удаление из списка по элементу и по индексу
- удаление всех данных из списка
- при любом обращении к индексу, который находится за пределами коллекции, необходимо бросить соответствующее исключение

Исходя из этого, создадим класс **Car**, объекты которого будут храниться в кастомной коллекции 

## Описание класса Car

package `base`;

`public class Car`..  
implements `Comparable<Car>`

| Конструктор                     | Описание                                     |
| --------------------------------|:---------------------------------------------|
| Car(String brand, int serialID) | Создает сущность Car с маркой и номером авто |


| Поле/Метод                     | Описание           |
| -------------------------------|:-------------------|
| String brand                   | Марка автомобиля   |
| int serialID                   | Номер автомобиля   |
| String getBrand()              | Возвращает марку авто  |
| void setBrand(String brand)    | Изменяет марку авто    |
| int getSerialID()              | Возвращает номера авто |
| void setSerialID(int serialID) | Измененяет номера авто |
| *@Override* String toString              | Возвращает информацию о классе `Car` |
| *@Override* boolean equals(Object obj)   | Указывает, "равен" ли другой объект `Car` этому объекту |
| *@Override* int hashCode()               | Возвращает числовое представление объекта |
| *@Override* int compareTo(Car o)         | Возвращает результат сравнения марки авто другого объекта с этим. Используется для сортировки |
| static Comparator\<Car\> compareById() | Возвращает результат сравнения номера авто. Используется для сортировки на основе этого атрибута |

Теперь реализуем систему учёта на уровне абстракции. Напишем интерфейс, в котором мы объявим все необходимые методы, описывая то, что должна делать эта система.

## Описание интерфейса JList

            JList<E>
            
package `base.collection`;

`public interface JList<E>`..  
extends `JCollection<E>`

| Метод                       | Описание                                                   |
| ----------------------------|:-----------------------------------------------------------|
| E get(int index)            | Возвращает элемент в указанной позиции в списке            |
| boolean add(E e)            | Вcегда возвращает `true`. Добавляет указанный элемент в конец списка |
| boolean add(E e, int index) | Всегда возвращает `true`. Добавляет указанный элемент в указанную позицию списка  |
| boolean remove(E e)         | Возвращает `true`, если элемент был найден в списке, удаляет первое вхождение указанного элемента из списка |
| boolean remove(int index)   | Возвращает `true` или `IndexOutOfBoundsException()`, если индекс меньше 0 или больше или равен размеру списка. Удаляет элемент в указанной позиции в списке |
| int size()                  | Возвращает количество элементов в списке |
| void clear()                | Удаляет все элементы из списка           |

Перед тем как приступить к реализации, лучше сначала написать тесты на интерфейс, а затем подставить нашу реализацию и проверить, что все тесты проходятся успешно. Такой подход к программированию называется Test Driven Development (TDD)..  

**Этими тестами можно проверить**   
- Получение элемента
- Выброс исключения IndexOutOfBoundException при получении/удалении ошибочного, несуществующего элемента
- Добавление N-ного кол-ва элементов в список и увеличение его размера на такое же кол-во
- Добавление элемента в начало/середину/конец списка
- Успешное удаление существующего элемента (также по индексу) при котором происходит уменьшение размера списка 
- Удаление несуществующего элемента не должно уменьшать размер списка
- После очистки списка его размер должен быть равен 0
- Успешный/неуспешный поиск элемента в списке
- Перебор элементов в цикле foreach (доп сложность)

Как только все тесты будут написаны, напишем коллекцию `JArrayList`, которая является копией уже существующего `ArrayList` 

## Описание класса JArrayList

            JList<E>
            /
        JArrayList<E>

package `base.collection`;

`public class JArrayList<E>`..  
implements `JList<E>`

| Конструктор       | Описание                                          |
| ------------------|:--------------------------------------------------|
| JArrayList()      | Создает пустой список с начальной ёмкостью десять |

| Поле/Метод                | Описание                                   |
| --------------------------|:-------------------------------------------|
| Object[] array            | Внутренний массив элементов типа 'Object'  |
| int size                  | Размер коллекции                           |
| void setDefaultValues()   | Устанавливает значения полей `array` и `size` по умолчанию: размер внутреннего массива равен 10, размер коллекции 0 |
| E get(int index)                              | Возвращает элемент в указанной позиции в коллекции                                              |
| void checkIndex(int index, boolean condition) | Выбрасывает `IndexOutOfBoundsException()`. Проверяет индекс элемента в коллекции, если `index` меньше 0 или `condition` равен `false`  |
| boolean add(E e)                              | Вcегда возвращает `true`. Добавляет указанный элемент в конец коллекции |
| void growOnFill(int index)  | Увеличивает размер массива, если размер коллекции больше или равен размеру массива    |
| boolean add(E e, int index) | Всегда возвращает `true`. Добавляет указанный элемент в указанную позицию коллекции   |
| boolean remove(E e)         | Возвращает `true`, если элемент был найден в коллекции, удаляет первое вхождение указанного элемента из коллекции |
| boolean remove(int index)   | Возвращает `true` или `IndexOutOfBoundsException()`, если индекс меньше 0 или больше или равен размеру коллекции. Удаляет элемент в указанной позиции в коллекции |
| int findElement(E e)        | Возвращает индекс элемента или -1, если он не найден в коллекции |
| boolean contains(E e)       | Возвращает `true` или `false`, если коллекция содержит указанный элемент   |
| int size()                  | Возвращает количество элементов в коллекции |
| void clear()                | Удаляет все элементы из коллекции        |
| *@Override* String toString | Возвращает информацию о коллекции        |
| Iterator<E> iterator()      | Возвращает перебор (итератор) по элементам в этой коллекции в правильной последовательности  |

----------

Как стало понятно, в основе такой коллекции лежит массив. Использование такой коллекции имеет несколько плюсов: быстрое получение и добавление в конец коллекции. 
Но при этом имеет минусы в виде медленного удаления элемента, медленной вставки в середину или начало коллекции. И самый главный минус - утечка памяти.
Возникающая, когда внутренний размер массива не изменяется при удалении элементов. Но есть возможность исправить эти недостатки, создав новый вид коллекции, в основе которой лежит связный список. Назовём его соответствующе `JLinkedList`.

----------

## Описание класса JLinkedList

            JList<E>
          /         \
    JArrayList<E>   JLinkedList<E>

package `base.collection`;

`public class JLinkedList<E>`..  
implements `JList<E>`, `JQueue<E>`

| Конструктор       | Описание                                          |
| ------------------|:--------------------------------------------------|
| JLinkedList()     | Создает пустой список с начальной ёмкостью десять |

| Поле/Метод                | Описание                                   |
| --------------------------|:-------------------------------------------|
| Node head | Ссылка на первый элемент коллекции    |
| Node tail | Ссылка на последний элемент коллекции |
| int size  | Размер коллекции                      |
| void setDefaultValues()     | Устанавливает значения полей `head`, `tail` и `size` по умолчанию: ссылка на первый и последний элементы равны `null`, размер коллекции 0 |
| E get(int index)            | Возвращает элемент в указанной позиции в коллекции  |
| Node getNode(int index)     | Возвращает ссылку ветви (`node`) по индексу         |
| boolean add(E e)            | Вcегда возвращает `true`. Добавляет указанный элемент в конец коллекции |
| boolean add(E e, int index) | Всегда возвращает `true`. Добавляет указанный элемент в указанную позицию коллекции |
| boolean remove(E e)         | Возвращает `true`, если элемент был найден в коллекции, удаляет первое вхождение указанного элемента из коллекции |
| boolean remove(int index)   | Возвращает `true` или `IndexOutOfBoundsException()`, если индекс меньше 0 или больше или равен размеру коллекции. Удаляет элемент в указанной позиции в коллекции |
| E remove()    | |
| E peek()      | |
| E poll()      | |
| int size()      | Возвращает количество элементов в коллекции |
| void clear()    | Удаляет все элементы из коллекции           |
| int findElement(E e)        | Возвращает индекс элемента или -1, если он не найден в коллекции          |
| boolean contains(E e)       | Возвращает `true` или `false`, если коллекция содержит указанный элемент  |
| *@Override* String toString | Возвращает информацию о коллекции  |
| Iterator<E> iterator()      | Возвращает перебор (итератор) по элементам в этой коллекции в правильной последовательности  |

`class Node<E>`

| Конструктор                            | Описание                              |
| ---------------------------------------|:--------------------------------------|
| Node(Node prev, E value, Node next)    | Создает ветвь с заданными параметрами |

| Поле/Метод | Описание                           |
| -----------|:-----------------------------------|
| Node prev  | Ссылка на предыдуший элемент ветви |
| E value    | Значение ветви                     |
| Node next  | ССылка на следующий элемент ветви  |
