# [Коллекции](https://github.com/Tirensky/JavaLearning/tree/master/Collections/src)
В стандартной библиотеке Java содержиться множество различных коллекции. И для понимания, чем каждая отличается друг от друга и как они устроены изнутри, я воссоздал некоторые коллекции в простом виде.
Для их изучния был выбран разбор тематической задачи "Система учёта автомобилей". Думаю, это также может помочь некоторым не оказаться в тупике, столкнувшись с дополнительными вопросами о внутреннем устройстве коллекций.



>  *Проект был создан с использованием системы сборки gradle и библиотеки JUnit5*



### Задача
Написать систему учёта автомобилей. Согласно требованию, нужен класс, который будет описывать авто и класс, который будет хранить в себе объекты этого (и любого другого) типа - то есть систему.
<dl>
  <dt>На первое время система должна реализовывать:</dt>
  <dd>- получение информации об автомобиле по индексу и их количество;</dd>
  <dd>- обавление нового автомобиля в список;</dd>
  <dd>- удаление из списка по элементу и по индексу;</dd>
  <dd>- удаление всех данных из списка;</dd>
  <dd>- при любом обращении к индексу, который находится за пределами коллекции, необходимо бросить соответствующее исключение.</dd>
</dl>

Создадим класс **Car**, объекты которого будут храниться в кастомной коллекции  

## Описание класса Car

package `base`;

`public class Car`..  
implements `Comparable<Car>`

| Конструктор                             | Описание                                     |
| ----------------------------------------|:---------------------------------------------|
| Car(String brand, int serialID)         | Создает сущность Car с маркой и номером авто |


| Поле/Метод                     | Описание           |
| -------------------------------|:-------------------|
| String brand                   | Марка автомобиля   |
| int serialID                   | Номер автомобиля   |
| String getBrand()              | Возвращает марку авто  |
| void setBrand(String brand)    | Изменяет марку авто    |
| int getSerialID()              | Возвращает номера авто |
| void setSerialID(int serialID) | Измененяет номера авто |
| @Override String toString              | Возвращает информацию о классе   |
| @Override boolean equals(Object obj)   | Указывает, "равен" ли другой объект `Car` этому объекту |
| @Override int hashCode()               | Возвращает числовое представление объекта |
| @Override int compareTo(Car o)         | Возвращает результат сравнения марки авто другого объекта с этим. Используется для сортировки |
| static Comparator\<Car\> compareById() | Возвращает результат сравнения номера авто. Используется для сортировки на основе этого атрибута |

Теперь можем реализовывать систему учёта на уровне абстракции. Напишем интерфейс, в котором мы объявим все необходимые методы, описывая то, что должна делать эта система.

## Описание интерфейса JList

                     ?
                     |
               JCollection<E>
               /
            JList<E>
            
package `base.collection`;

`public interface JList<E>`..  
extends `JCollection<E>`

| Метод                       | Описание                                                   |
| ----------------------------|:-----------------------------------------------------------|
| E get(int index)            | Получение элемента по индексу. Возвращает элемент типа `E` |
| boolean add(E e)            | Добавление элемента в список. Вcегда возвращает `True`     |
| boolean add(E e, int index) | Добавление элемента в список, в указанное место. Всегда возващает `True` |
| boolean remove(E e)         | Удаление элемента из списка. Возвращает `True`, если элемент был найден в списке и это элемент удалось удалить по индексу |
| boolean remove(int index)   | Удаление элемента по индексу из списка. Возвращает `True` или `IndexOutOfBoundsException()`, если индекс меньше 0 или больше или равен размеру списка  |
| int size()                  | Возвращает размер списка |
| void clear()                | Очищает весь список      |

Перед тем как приступить к реализации, лучше сначала написать тесты на интерфейс, а затем подставить нашу реализацию и проверить, что все тесты проходятся успешно. Такой подход к программированию называется Test Driven Development (TDD)..  

**Этими тестами можно проверить**   
- Получение элемента
- Выброс исключения IndexOutOfBoundException при получении/удалении ошибочного, несуществующего элемента
- Добавление N-ного кол-ва элементов в список и увеличение его размера на такое же кол-во
- Добавление элемента в начало/середину/конец списка
- Успешное удаление существующего элемента (также по индексу) при котором происходит уменьшение размера списка 
- Удаление несуществующего элемента не должно уменьшать размер списка
- После очистки списка его размер должен быть равен 0
- Успешный/неуспешный поиск элемента в списке
- Перебор элементов в цикле Foreach (доп сложность)


